// ********RoostGPT********
/*
Test generated by RoostGPT for test api-test using AI Type Claude AI and AI Model claude-3-opus-20240229

Test generated for /accounts_patch for http method type PATCH in rest-assured framework

RoostTestHash=2758affb7e


*/

// ********RoostGPT********
package com.bootexample4.RoostTest;

import io.restassured.RestAssured;
import io.restassured.path.json.JsonPath;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static io.restassured.RestAssured.given;
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.List;
import org.hamcrest.MatcherAssert;
import static org.hamcrest.Matchers.*;
import org.json.JSONObject;
import org.json.XML;
import org.json.JSONException;
import java.util.Arrays;

public class AccountsPatchTest {

    private List<Map<String, String>> envList = new ArrayList<>();

    @BeforeEach
    public void setUp() {
        TestdataLoader dataloader = new TestdataLoader();
        String[] envVarsList = {""};
        envList = dataloader.load("src/test/java/com/bootexample4/RoostTest/accountsPatchTest.csv", envVarsList);
    }

    @Test
    public void accountsPatchTest() throws JSONException {
        setUp();
        int testNumber = 1;
        for (Map<String, String> testData : envList) {
            String baseUrl = testData.getOrDefault("BASE_URL", "https://virtserver.swaggerhub.com/credentialregister/wallet/1.0.0");
            RestAssured.baseURI = baseUrl;

            Response response = given()
                    .contentType(ContentType.JSON)
                    .body("{\n" +
                            "  \"email\": \"" + testData.getOrDefault("email", "") + "\"\n" +
                            "}")
                    .when()
                    .patch("/accounts")
                    .then()
                    .extract().response();

            JsonPath jsonResponse = getJsonResponse(response);

            System.out.printf("Test Case %d: accountsPatchTest \n", testNumber++);
            System.out.println("Request: PATCH /accounts");
            System.out.println("Status Code: " + response.statusCode());

            int expectedStatusCode = testData.containsKey("statusCode") ? Integer.parseInt(testData.get("statusCode")) : 0;
            if (expectedStatusCode != 0) {
                MatcherAssert.assertThat(response.statusCode(), equalTo(expectedStatusCode));
            } else {
                List<Integer> expectedStatusCodes = Arrays.asList(200, 400);
                MatcherAssert.assertThat(response.statusCode(), is(in(expectedStatusCodes)));
            }

            switch (response.statusCode()) {
                case 200:
                    System.out.println("Description: successful operation");
                    break;
                case 400:
                    validateErrorResponse(jsonResponse);
                    break;
                case 404:
                    validateNotFoundResponse(jsonResponse);
                    break;
                case 422:
                    validateUnprocessableEntityResponse(jsonResponse);
                    break;
            }
        }
    }

    private JsonPath getJsonResponse(Response response) {
        String contentType = response.getContentType();
        if (contentType.contains("application/xml") || contentType.contains("text/xml")) {
            String xmlResponse = response.asString();
            JSONObject jsonObject = XML.toJSONObject(xmlResponse);
            return new JsonPath(jsonObject.getJSONObject("xml").toString());
        } else if (contentType.contains("application/json")) {
            return response.jsonPath();
        } else {
            throw new IllegalStateException("Unsupported response content type: " + contentType);
        }
    }

    private void validateErrorResponse(JsonPath jsonResponse) {
        System.out.println("Description: Bad Request");
        MatcherAssert.assertThat(jsonResponse.get("error"), instanceOf(String.class));
        MatcherAssert.assertThat(jsonResponse.get("description"), instanceOf(String.class));
        MatcherAssert.assertThat(jsonResponse.getString("error"), matchesPattern("^validation/.*$"));
        MatcherAssert.assertThat(jsonResponse.get("value"), notNullValue());
        MatcherAssert.assertThat(jsonResponse.get("field"), instanceOf(String.class));
        MatcherAssert.assertThat(jsonResponse.get("schema_field"), instanceOf(String.class));
    }

    private void validateNotFoundResponse(JsonPath jsonResponse) {
        System.out.println("Description: Not Found");
        MatcherAssert.assertThat(jsonResponse.get("error"), equalTo("not_found"));
        MatcherAssert.assertThat(jsonResponse.get("message"), instanceOf(String.class));
    }

    private void validateUnprocessableEntityResponse(JsonPath jsonResponse) {
        System.out.println("Description: Unprocessable Entity");
        MatcherAssert.assertThat(jsonResponse.get("error"), equalTo("validation_failed"));
        MatcherAssert.assertThat(jsonResponse.get("errors"), instanceOf(List.class));
        List<Map<String, String>> errors = jsonResponse.getList("errors");
        for (Map<String, String> error : errors) {
            MatcherAssert.assertThat(error.get("field"), instanceOf(String.class));
            MatcherAssert.assertThat(error.get("message"), instanceOf(String.class));
        }
    }
}
