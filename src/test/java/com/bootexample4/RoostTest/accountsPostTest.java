// ********RoostGPT********
/*
Test generated by RoostGPT for test api-test using AI Type Claude AI and AI Model claude-3-opus-20240229

Test generated for /accounts_post for http method type POST in rest-assured framework

RoostTestHash=53e96f9805


*/

// ********RoostGPT********
package com.bootexample4.RoostTest;

import io.restassured.RestAssured;
import io.restassured.path.json.JsonPath;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static io.restassured.RestAssured.given;
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.List;
import org.hamcrest.MatcherAssert;
import static org.hamcrest.Matchers.*;
import org.json.JSONObject;
import org.json.XML;
import org.json.JSONException;
import java.util.Arrays;

public class AccountsPostTest {

    private List<Map<String, String>> envList = new ArrayList<>();

    @BeforeEach
    public void setUp() {
        TestdataLoader dataloader = new TestdataLoader();
        String[] envVarsList = {""};
        envList = dataloader.load("src/test/java/com/bootexample4/RoostTest/accountsPostTest.csv", envVarsList);
    }

    @Test
    public void accountsPostTest() throws JSONException {
        setUp();
        int testNumber = 1;
        for (Map<String, String> testData : envList) {
            String baseUrl = testData.getOrDefault("BASE_URL", "https://virtserver.swaggerhub.com/credentialregister/wallet/1.0.0");
            RestAssured.baseURI = baseUrl;

            Response responseObj = given()
                    .header("commit-hash", testData.getOrDefault("commit-hash", ""))
                    .contentType(ContentType.JSON)
                    .body("{\n" +
                            "  \"email\": \"" + testData.getOrDefault("email", "") + "\"\n" +
                            "}")
                    .when()
                    .post("/accounts")
                    .then()
                    .extract().response();
            JsonPath response;
            String contentType = responseObj.getContentType();

            System.out.printf("Test Case %d: accountsPostTest \n", testNumber++);
            System.out.println("Request: POST /accounts");
            System.out.println("Status Code: " + responseObj.statusCode());
            if (testData.containsKey("statusCode")) {
                MatcherAssert.assertThat(responseObj.statusCode(), equalTo(Integer.parseInt(testData.get("statusCode"))));
            } else {
                List<Integer> expectedStatusCodes = Arrays.asList(201, 400);
                MatcherAssert.assertThat(responseObj.statusCode(), is(in(expectedStatusCodes)));
            }

            switch (responseObj.statusCode()) {
                case 400:
                    validateErrorResponse(responseObj);
                    break;
                case 404:
                    validateNotFoundResponse(responseObj);
                    break;
                case 422:
                    validateUnprocessableEntityResponse(responseObj);
                    break;
                default:
                    break;
            }

            if (contentType.contains("application/xml") || contentType.contains("text/xml")) {
                String xmlResponse = responseObj.asString();
                JSONObject jsonResponse = XML.toJSONObject(xmlResponse);
                JSONObject jsonData = jsonResponse.getJSONObject("xml");
                String jsonString = jsonData.toString();
                response = new JsonPath(jsonString);
            } else if (contentType.contains("application/json")) {
                response = responseObj.jsonPath();
            } else {
                System.out.println("Response content type found: " + contentType + ", but RoostGPT currently only supports the following response content types: application/json, text/xml, application/xml");
                continue;
            }

            if (responseObj.statusCode() == 201) {
                System.out.println("Description: successful operation");
            }
        }
    }

    private void validateErrorResponse(Response responseObj) {
        JsonPath response = responseObj.jsonPath();
        MatcherAssert.assertThat(responseObj.getContentType(), equalTo("application/json"));

        if (response.get("error") != null) {
            MatcherAssert.assertThat(response.get("error"), instanceOf(String.class));
            MatcherAssert.assertThat(response.getString("error"), matchesPattern("^validation/.*$"));
        }

        if (response.get("description") != null) {
            MatcherAssert.assertThat(response.get("description"), instanceOf(String.class));
        }

        if (response.get("value") != null) {
            MatcherAssert.assertThat(response.get("value"), instanceOf(Object.class));
        }

        if (response.get("field") != null) {
            MatcherAssert.assertThat(response.get("field"), instanceOf(String.class));
        }

        if (response.get("schema_field") != null) {
            MatcherAssert.assertThat(response.get("schema_field"), instanceOf(String.class));
        }
    }

    private void validateNotFoundResponse(Response responseObj) {
        JsonPath response = responseObj.jsonPath();
        MatcherAssert.assertThat(responseObj.getContentType(), equalTo("application/json"));

        if (response.get("error") != null) {
            MatcherAssert.assertThat(response.get("error"), instanceOf(String.class));
            MatcherAssert.assertThat(response.getString("error"), equalTo("not_found"));
        }

        if (response.get("description") != null) {
            MatcherAssert.assertThat(response.get("description"), instanceOf(String.class));
            MatcherAssert.assertThat(response.getString("description"), equalTo("The requested resource was not found."));
        }
    }

    private void validateUnprocessableEntityResponse(Response responseObj) {
        JsonPath response = responseObj.jsonPath();
        MatcherAssert.assertThat(responseObj.getContentType(), equalTo("application/json"));

        if (response.get("error") != null) {
            MatcherAssert.assertThat(response.get("error"), instanceOf(String.class));
            MatcherAssert.assertThat(response.getString("error"), equalTo("unprocessable_entity"));
        }

        if (response.get("description") != null) {
            MatcherAssert.assertThat(response.get("description"), instanceOf(String.class));
            MatcherAssert.assertThat(response.getString("description"), equalTo("The request was well-formed but was unable to be followed due to semantic errors."));
        }
    }
}
